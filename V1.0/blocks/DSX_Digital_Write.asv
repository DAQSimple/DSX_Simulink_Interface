function DSX_Digital_Write(block)
    setup(block);
    %endfunction
function setup(block)
    block.NumDialogPrms =1; %Number of variables to import from mask

    %% Register number of input and output ports
    block.NumInputPorts  = 1;
    block.NumOutputPorts = 0;

    %% Setup functional port properties
    block.SetPreCompInpPortInfoToDynamic;
    block.SetPreCompOutPortInfoToDynamic;
    block.InputPort(1).Dimensions        = 1;
    block.InputPort(1).DirectFeedthrough = false
    %% Set block sample time to inherited
    block.SampleTimes = [-1 0];

    %% Set the block simStateCompliance to default (i.e., same as a built-in block)
    block.SimStateCompliance = 'DefaultSimState';
    %% Register methods
    block.RegBlockMethod('InitializeConditions', @InitializeConditions);
    block.RegBlockMethod('Start', @Start);
    block.RegBlockMethod('Update', @Update);
    block.RegBlockMethod('Terminate', @Terminate); % Required
function InitializeConditions(block)
    Serial_Config_callback('init'); % ensure serial port connection
    flush(evalin('base','DSX'));    % flush serial buffer just in case
    
function Start (block)
 Serial_Send_callback('send',toCommand(block.DialogPrm(1).Data, block.InputPort(1).Data));
 
function Update (block)
Serial_Send_callback('send',toCommand(block.DialogPrm(1).Data, block.InputPort(1).Data));

function Terminate(block)
Serial_Send_callback('send',toCommand(block.DialogPrm(1).Data, 0)); % send final value, off
flush(evalin('base','DSX'));

function command = toCommand(pin,val)
assignin('base','pin',pin);
assignin('base','val',val);
if val > 1
    val = 1;
end
if size(pin) == 1
    pin = strcat('0',pin);
end
command = sprintf('%i',str2num(strcat('10',pin,'1','000',num2str(val),'0')));
assignin('base','digitalwritecommand',command);