function [pingOut] = DSX_Read_callback(command,spec)
%% Checks
w=evalin('base','whos');
exist_sBuffer = ismember('sBuffer',[w(:).name]);
exist_DSX = ismember('DSX',[w(:).name]);
% exist_sBuffer = ismember('dsx_struct',[w(:).name]);
% exist_sBuffer = exist('sBuffer');
if ~exist('spec')
    spec = [];
else
    spec = char(spec); % its char for sure now
end
%% Define current command in a struct
[id,loc,sign,val,ret] = splitping(spec);  
%% Checks
if exist_sBuffer  
    sBuffer = evalin('base','sBuffer');
else
    sBuffer = [];
end
if exist_DSX
    DSX = evalin('base','DSX');
else
    Serial_Config_callback('init');
end
%% Initialize output
pingOut = '0';
%% Commands
    switch command
        % no input needed, only specify 'read' 
        case 'readnext'
            %% Ask DSX for value 
            writeline(DSX,spec);
            %% Read next line in serial buffer
            pingOut = char(readline(DSX));
            %% Ensure the command is valid, else discard
            if numel(pingOut)>9
                    new_sBuffer = [sBuffer;pingOut];      % add ping to end 
                    assignin('base','sBuffer',new_sBuffer); % update sBuffer in base workspace
            end        
        case 'checkBuffer'   
            %% If ping(s) we want are in buffer
            [index,pingOut] = inBuffer(sBuffer, id, loc);
            if index >0
                zbuf(1,:) =[]
%                 sBuffer = sBuffer(sBuffer ~= sBuffer(:,index));
    
                assignin('base','sBuffer',sBuffer); % update sBuffer in base workspace     
            end
        case 'read'
            pingOut = readline(evalin('base','DSX'));       
    end
% end function